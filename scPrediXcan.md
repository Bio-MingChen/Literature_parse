# scPrediXcan integrates advances in deep learning and single-cell data into a powerful cell-type–specific transcriptome-wide association study framework

你的问题非常关键，下面我一一详细解答，确保你对整个框架的核心逻辑完全吃透：

---

## ✅ **1. 什么是 S-PrediXcan？**

### 📌 S-PrediXcan = Summary-based PrediXcan

这是对经典 PrediXcan 框架的一个**改进版**，它的目的在于：

> **在只有 GWAS summary statistics（而没有个体级别 genotype 数据）时，也能进行 TWAS 分析。**

---

### 🔬 PrediXcan vs. S-PrediXcan 对比：

| 特点     | PrediXcan                      | **S-PrediXcan**                         |
| -------- | ------------------------------ | --------------------------------------- |
| 输入     | SNP dosage（个体级别）         | SNP GWAS summary statistics（β, SE, Z） |
| 表达预测 | 使用训练好的表达预测模型       | 使用表达预测模型的权重（W）             |
| 输出     | gene-level association Z-score | gene-level Z-score + p-value            |
| 优势     | 精度高，能做个体分析           | 数据易获取、计算高效、隐私友好          |

---

### 🧠 关键计算公式：

如果我们有某个基因 $g$，其在 GWAS summary 中关联的 SNP 是 $l$，
S-PrediXcan 的 Z-score 计算公式如下：

$$
Z_g = \sum_{l \in \text{cis}(g)} \omega_{g,l} \cdot \frac{\hat{\sigma}_l}{\hat{\sigma}_g} \cdot \frac{\hat{\beta}_l}{\text{SE}(\hat{\beta}_l)}
$$

其中：

- $\omega_{g,l}$：基因 $g$ 的线性预测模型中第 $l$ 个 SNP 的权重（从 ℓ-ctPred 得到）
- $\hat{\beta}_l$：第 $l$ 个 SNP 的 GWAS 回归系数（summary stat）
- $\hat{\sigma}_l$：SNP 的方差（估计 SNP 的影响尺度）
- $\hat{\sigma}_g$：预测表达量的标准差

最终可以计算出每个基因的 Z-score 和 p-value，用于判断其是否与疾病相关。

---

## ✅ **2. 作者是否是用 462 个个体做 WES → Enformer → MLP 表达预测？**

这个理解基本是正确的，但细节再精化一下：

---

### 🧬 输入数据：

| 数据类型                       | 来源                                                       | 用途                                                     |
| ------------------------------ | ---------------------------------------------------------- | -------------------------------------------------------- |
| 🧬 Whole-genome sequence (WGS) | 462 个欧洲个体（来自 1000 Genomes）                        | 输入 Enformer，生成每个基因的 epigenomic 特征（5313 维） |
| 🧪 RNA-seq 表达数据            | 来自不同 scRNA-seq 数据集（如 OneK1K）中构建的 pseudo-bulk | 用作目标值 $y$                                           |

---

### 🔁 操作流程：

1. 对每个基因，截取其 TSS 附近 196kb 序列，输入 Enformer，得到该基因的 epigenomic 表征 $x \in \mathbb{R}^{5313}$
2. 对于每个 cell type，把 scRNA-seq 按个体进行 pseudo-bulk 聚合，计算每个个体的表达值（转成百分位 rank）
3. 用这些 $x$ 和 $y$ 训练一个 4 层的全连接神经网络（ctPred）

所以训练目标其实是：

$$
\text{ctPred}: \text{Enformer}(DNA_i) = x_i \rightarrow y_i = \text{expression percentile}
$$

- 这个模型是 **cell type-specific** 的，每种细胞类型一个模型

---

## ✅ **3. 非线性模型转向线性模型：一个具体例子**

我们用一个**简单的小例子**，帮助你理解如何把非线性神经网络（ctPred）预测表达的过程“压缩”为一个线性 SNP 模型（ℓ-ctPred）：

---

### 🎯 场景设定：

假设我们想预测基因 G 的表达（y），我们有 3 个 SNP（s1, s2, s3），它们影响该基因的调控。

---

### 🧩 步骤 1：从基因序列生成 Enformer 表观特征

| Individual | Sequence (TSS ± 100kb) | Enformer 输出 (5313-d vector) |
| ---------- | ---------------------- | ----------------------------- |
| A          | ACTG…                  | \[0.1, 0.5, ..., 0.03]        |
| B          | AGCG…                  | \[0.12, 0.45, ..., 0.05]      |
| …          | …                      | …                             |

---

### 🤖 步骤 2：ctPred 预测表达（非线性）

- 把上面的 Enformer 向量输入 MLP，输出一个表达值，比如 0.62（代表 62% percentile）

---

### 🪄 步骤 3：构建线性模型 ℓ-ctPred

- 把上一步的“预测表达值”当成**标签值**
- 用这些表达值做目标，用每个个体的 SNP genotype (dosage: 0/1/2) 做特征，训练一个 linear model：

$$
y_i = w_1 \cdot \text{SNP}_1 + w_2 \cdot \text{SNP}_2 + w_3 \cdot \text{SNP}_3 + \epsilon
$$

这就得到了一个线性模型：

| SNP | 权重 $w$ |
| --- | -------- |
| s1  | 0.3      |
| s2  | -0.1     |
| s3  | 0.02     |

---

### ✅ 这样我们就完成了：

- 原本从基因序列 → Enformer → MLP → 表达预测（非线性）
- 现在变成了：从 SNP → 加权 → 表达预测（线性）

然后这个线性模型就可以用在 `S-PrediXcan` 里面，搭配 GWAS summary statistics 做 TWAS！

---

## 🧠 总结一句话

> Enformer 是把 DNA 序列“翻译”为调控潜能（epigenomic features）的工具，MLP 是预测表达的模型，ℓ-ctPred 是最终为 TWAS 使用的线性模型。非线性转线性就是把表达预测的“复杂过程”转写成 SNP 的线性组合。

---

如果你想，我可以把整个流程画一个图（从 DNA → Enformer → ctPred → ℓ-ctPred → TWAS），会更直观。你需要我画吗？

✅ 非常棒的问题！你这句话精准地指出了很多人初学这个方法时会感到困惑的地方：

> **“ctPred 训练集里面每个基因只有一个参考序列（没有个体差异），那它怎么学到这个模型，并泛化到其他基因上？”**

答案是：**ctPred 是以“每个基因”为一条训练样本，而不是像传统神经网络那样从大量个体的“同一个输入模板”中学习规律。它是“跨基因学习”，不是“跨个体学习”。**

---

## 🧠 所以你的问题本质是：

> “ctPred 怎么在只有每个基因一条数据的情况下学出一个泛化的表达预测模型？”

---

## ✅ 答案简要：

> **它训练的是“跨基因”的模型，不是“跨样本”模型。**
> 对于一个特定细胞类型，它收集上万个基因的输入（Enformer 输出）和输出（表达百分位），这样样本量是“基因数量”，不是“个体数量”。

---

## 🧬 更具体地说：

### 假设你选定一个细胞类型（例如：B cell）

你可以构建如下训练集：

| 基因名 | Enformer 输出 (5313 维) | B 细胞中表达百分位（0\~1） |
| ------ | ----------------------- | -------------------------- |
| G1     | \[0.2, 0.5, ...]        | 0.84                       |
| G2     | \[0.8, 0.1, ...]        | 0.23                       |
| G3     | \[0.12, 0.35, ...]      | 0.05                       |
| G4     | \[0.7, 0.65, ...]       | 0.91                       |
| ...    | ...                     | ...                        |

注意：这一行一行不是不同个体的同一个基因，而是不同**基因本身**。

- 所以样本量是上万个基因（约 18,000）
- 每个基因有它自己唯一的参考序列 → 输入 Enformer → 得到 feature 向量
- 每个基因在该细胞类型下有一个 pseudo-bulk 表达百分位 → 作为 label

### 🔁 ctPred 学的是：

> **哪些 DNA 调控特征模式（由 Enformer 给出）会导致基因在特定细胞类型中表达更高？**

---

## ✅ 一个比喻帮你理解

你可以想象：

- 每个基因是一位“独立的样本”
- 它的 DNA 上有哪些 epigenomic 特征（如染色质开放性、转录因子 binding 等）→ 是它的“输入”
- 它在某种细胞类型中的表达水平 → 是“输出”
- ctPred 就是在学“什么样的 DNA 调控特征 → 导致基因高表达”

**不是用多个人学同一个基因，而是用多种基因学调控规律！**

---

## ✅ 总结一下回答：

> ctPred 的训练不是“一个基因一条样本”，而是“一个基因在一个细胞类型中是一条样本”，它通过在一个细胞类型中遍历上万个基因，学习基因结构与表达之间的普适映射规律。虽然每个基因只有一个序列，但基因本身成千上万，因此足以支撑模型训练。

---

如果你感兴趣，我可以用可视化图像画出“ctPred 的训练数据格式是什么样子”，或者做一个 mock 数据来跑一遍训练。你希望我帮你做哪种？

太好了！你现在问的是整个方法里**最核心的一步**之一：

> **ℓ-ctPred 是如何建立的？用哪些 SNP？如何拟合出表达模型？能不能给个详细例子？**

我来详细地一步一步说明，并给你一个具体的例子，帮助你从原理到操作都理解透彻。

---

## ✅ ℓ-ctPred 是什么？

ℓ-ctPred 是一个 **线性模型**，它表示：

> 某个基因的表达（ctPred 模拟出的）
> ≈ 某些 SNP 的基因型 dosage 的线性组合
> 可表示为：
>
> $$
> $$

\hat{E}\_G = \omega_1 \cdot \text{SNP}\_1 + \omega_2 \cdot \text{SNP}\_2 + \cdots + \omega_k \cdot \text{SNP}\_k
]

这些权重 $\omega_i$ 是用 **Elastic Net 回归** 拟合得到的，就是 ℓ-ctPred 的“核心成果”。

---

## ✅ 整体流程图概览：

```plaintext
个体 WGS 序列
     ↓
[Enformer] → 5313维 epigenomic 特征
     ↓
[ctPred] → 模拟表达值（in-silico expression）
     ↓
[Elastic Net 回归]
     ↓
SNP genotype → 模拟表达
     ↓
得到 SNP 权重：ℓ-ctPred
```

---

## 🧪 举个具体例子说明 ℓ-ctPred 的建立过程

### 场景：我们想构建“基因 G 在 B 细胞中”的 ℓ-ctPred 模型

---

### 🧬 Step 1：从 WGS 数据得到个体基因组序列

你有 3 个个体（简化演示）：

| 个体 ID | 基因 G 的序列（含突变） |
| ------- | ----------------------- |
| A       | ACTGGTA...（rs1 = G）   |
| B       | ACTAGTA...（rs1 = A）   |
| C       | ACTGGTA...（rs1 = G）   |

---

### 🧬 Step 2：输入 Enformer，得到个体化表观特征（5313 维）

然后你把这些个体特异序列输入 Enformer，得到：

| 个体 ID | Enformer 输出（简化为 3 维） |
| ------- | ---------------------------- |
| A       | \[0.1, 0.4, 0.3]             |
| B       | \[0.2, 0.3, 0.5]             |
| C       | \[0.05, 0.6, 0.2]            |

---

### 🧠 Step 3：输入 ctPred → 得到表达预测值

用训练好的 ctPred 模型预测表达百分位：

| 个体 ID | Enformer → ctPred → 模拟表达 |
| ------- | ---------------------------- |
| A       | 0.63                         |
| B       | 0.45                         |
| C       | 0.70                         |

这就是你建模的 target $y$

---

### 🧬 Step 4：获取这 3 个个体在基因 G 附近的 SNP genotype（假设有 3 个 SNP）

| 个体 ID | rs1 | rs2 | rs3 |
| ------- | --- | --- | --- |
| A       | 2   | 1   | 0   |
| B       | 0   | 2   | 1   |
| C       | 2   | 0   | 0   |

（0/1/2 是基因型 dosage，代表突变次数）

---

### 🧪 Step 5：用这些 SNP → 拟合表达值

你现在要做的就是拟合这个线性回归：

$$
\hat{E}_G = \omega_1 \cdot \text{rs1} + \omega_2 \cdot \text{rs2} + \omega_3 \cdot \text{rs3}
$$

数据矩阵是：

**X（SNP 矩阵）**：

```
[[2, 1, 0],
 [0, 2, 1],
 [2, 0, 0]]
```

**y（ctPred 预测的表达）**：

```
[0.63, 0.45, 0.70]
```

---

### ✅ Step 6：Elastic Net 拟合（带 L1+L2 正则）

这一步用的是 `ElasticNetCV`，输出权重例如：

| SNP | 权重 $\omega$ |
| --- | ------------- |
| rs1 | 0.12          |
| rs2 | -0.05         |
| rs3 | 0             |

这个系数就是你最终得到的 ℓ-ctPred 权重。你现在就能做：

- **TWAS（S-PrediXcan）**
- **在新数据上预测表达**
- **可视化 SNP 分布贡献**

---

## ✅ 那么选哪些 SNP 呢？

这一步在文献中明确：

> “We included all SNPs in cis-region of the gene (±1Mb from TSS)... used the same SNP filters as GTEx PredictDB models: MAF > 0.01, HWE p > 1e-6, genotype missing rate < 0.05”

### 📌 所以：

- 只选 ±1Mb 的 **cis-SNP**
- 过滤掉低频、异常偏离 Hardy-Weinberg 的 SNP
- 和 PrediXcan 模型保持一致，方便对比

---

## ✅ 总结整个过程：

| 步骤 | 数据                | 操作                                |
| ---- | ------------------- | ----------------------------------- |
| 1️⃣   | 个体 WGS 序列       | 提取每个基因的 TSS ±98kb            |
| 2️⃣   | DNA 序列 → Enformer | 得到 epigenomic 特征                |
| 3️⃣   | Enformer → ctPred   | 得到个体化表达值（y）               |
| 4️⃣   | SNP dosage（X）     | 从 VCF 提取                         |
| 5️⃣   | Elastic Net 回归    | 得到 ℓ-ctPred 权重（每个 SNP 一个） |

---

如果你希望，我可以给你写一段 Python toy 代码，模拟这个过程，包括：生成假 SNP + 假表达 + 回归出 ℓ-ctPred。你想要代码演示吗？

✅ 很棒的问题！你现在已经站在了“TWAS 与 eQTL 模型本质区别”的门口。
我们来详细、系统地比较：

---

## 🎯 你的问题：

> **ℓ-ctPred 的建立过程，和传统 eQTL 的效应值（β）是怎么获得的，是一样的吗？**

### 简短回答：

> ❌ **不完全一样**，尽管它们最终都给出了“某个 SNP 对基因表达的影响大小（权重）”，
> ✅ 但它们**建模方式、目标、结果的含义都不同**。

我们来详细比较。

---

## ✅ 一张总表：ℓ-ctPred vs eQTL 的权重来源对比

| 比较项           | **传统 eQTL β**                             | **ℓ-ctPred 权重 $\omega$**                     |
| ---------------- | ------------------------------------------- | ---------------------------------------------- |
| 模型目的         | 找出 SNP 与表达的统计相关性（检测是否显著） | 拟合一个表达预测模型（关注解释力）             |
| 输入数据         | 个体级 SNP + RNA-seq（真实）                | 个体级 SNP + pseudo-expression（ctPred 预测）  |
| 模型形式         | 单变量线性回归（逐个 SNP）                  | 多变量 Elastic Net 回归（多个 SNP 同时拟合）   |
| 输出含义         | SNP 是否是 eQTL（有无显著影响）             | 该 SNP 是否有预测价值（被用于预测表达）        |
| 是否稀疏建模     | ❌ 否，一般每个 SNP 都计算 β 和 p           | ✅ 是，Elastic Net 自动筛除无关 SNP（L1 正则） |
| 是否提供 p-value | ✅ 是，核心输出                             | ❌ 否，仅输出回归系数                          |
| 最终目标         | 筛选调控 SNP（机制研究）                    | 用表达做 TWAS（应用预测）                      |

---

## ✅ 举个例子说明差异

### 🧪 eQTL：

你对 SNP rs123 做线性回归：

$$
\text{expression} = \beta \cdot \text{rs123 dosage} + \epsilon
$$

得到 β = 0.13，p = 1e-6 → 说明 rs123 可能是 G 的 cis-eQTL

---

### 🧠 ℓ-ctPred：

你同时用多个 SNP 预测 ctPred 输出的表达值：

$$
\text{ctPred(expression)} = \omega_1 \cdot \text{rs1} + \omega_2 \cdot \text{rs2} + \cdots
$$

使用 Elastic Net 回归 → 得到一组权重（部分为 0），没有 p 值
目标是“构建一个高质量表达预测模型”，不是判断显著性

---

## 🧠 理解核心本质差别：

### 🧬 eQTL 是一种**显著性检测问题**：

> 在真实人群中：
> “这个 SNP 的不同基因型是否与表达量差异显著相关？”

- 样本数越多，检测力越强
- 要控制假阳性（需要 p-value、FDR）

---

### 🤖 ℓ-ctPred 是一种**预测建模问题**：

> 给你某个个体的基因型，能不能准确预测他的表达？
> → 所以用的是 Elastic Net 等机器学习方法，优化的是拟合误差（MSE）

- 不关注单个 SNP 的 p 值
- 更关注组合效应是否能拟合表达

---

## ✅ 结果表现形式也不同：

| 项目          | eQTL                | ℓ-ctPred                   |
| ------------- | ------------------- | -------------------------- |
| SNP 权重      | β（可能很小但显著） | $\omega$（可能大但不显著） |
| p-value       | 是                  | 否                         |
| 可否用于 TWAS | ❌ 通常不行         | ✅ 是设计目标              |

---

## ✅ 总结一句话：

> **eQTL 是为解释生物机制（SNP → 表达显著性）而设计，** > **ℓ-ctPred 是为构建表达预测模型（SNP → 表达拟合）而设计，尽管它们都生成“某个 SNP 对表达的影响系数”，但它们的来源、含义、数学过程、应用场景**是完全不同的。

---

如果你想看“同一批数据下 eQTL 和 ℓ-ctPred 权重差异的可视化比较”，我可以给你画出权重对比图。需要吗？

非常好，这个问题非常关键也很深刻！

你问：

> Elastic Net 是啥？看起来不就是极大似然估计得出的一组 $\omega$ 值嘛？

✅ **你说得没错，Elastic Net 最终确实是通过优化一个目标函数（等价于“广义极大似然”）来求一组回归系数 $\omega$。**
但它的**关键作用不仅仅是估计，而是**在“高维、多共线性、自变量多于样本数”等场景下，**进行变量筛选与防止过拟合**。

---

## ✅ 先来看标准的回归模型（你说的“极大似然”）

普通线性回归是：

$$
\hat{y} = X\omega
$$

优化目标是最小化残差平方和（最小二乘）：

$$
\min_{\omega} \| y - X\omega \|_2^2
$$

这等价于在假设误差服从正态分布下的极大似然估计（MLE）。

---

## 🚨 问题来了：

当特征数远大于样本数（比如 SNP 个数上千，而样本才几百个），或者 SNP 之间高度共线（LD），你就会遇到：

- 解不唯一
- 模型极度过拟合
- 很难做变量选择

---

## ✅ Elastic Net 的目标：

> **在回归的基础上，加上正则项（惩罚项）来控制模型复杂度，兼顾 L1（稀疏性）和 L2（稳定性）**

它的目标函数是：

$$
\min_{\omega} \| y - X\omega \|_2^2 + \lambda_1 \|\omega\|_1 + \lambda_2 \|\omega\|_2^2
$$

其中：

- $\|\omega\|_1$：L1 范数（Lasso） → 让一些权重变为 0，实现变量选择（feature selection）
- $\|\omega\|_2^2$：L2 范数（Ridge） → 让权重尽量小，缓解共线性，提高稳健性

---

## ✅ 为什么 TWAS 中使用 Elastic Net？

这是因为在表达预测模型（如 ℓ-ctPred）中：

- 每个基因附近（±1Mb）有上千个 SNP → 自变量数量远大于样本数（n << p）
- SNP 之间高度共线（尤其是在 LD block 内）
- 想要一个稀疏且稳健的表达预测模型

Elastic Net 兼顾了：

| 目标             | 方法                             |
| ---------------- | -------------------------------- |
| 选出重要 SNP     | L1 惩罚（让不重要 SNP 权重为 0） |
| 抑制过拟合       | L2 惩罚（限制权重大小）          |
| 对共线特征更鲁棒 | L2 提供稳定性，比 Lasso 更稳     |

---

## ✅ 所以你说 Elastic Net 是“极大似然估计的一种”，没错！

- 它确实是在线性模型的极大似然框架下，加入惩罚项的变体
- 它的求解方式（比如坐标下降法）和 Ridge/Lasso 十分类似
- 在 scikit-learn 里对应的模型就是 `ElasticNet` / `ElasticNetCV`

---

## ✅ 总结一句话：

> **Elastic Net = 极大似然 + L1 + L2 惩罚项**，它是为了解决“高维、多共线、变量选择”问题的线性建模方法。
> 在 TWAS 的 ℓ-ctPred 建模中，它可以自动选出最有用的 SNP，并避免过拟合，是表达预测的首选回归器。

---

如果你想，我可以用一段 Python 代码给你演示 ElasticNet 在 SNP 数据上的回归过程，包括输出哪些 SNP 被选中、权重是多少。要吗？
